{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the AniStream platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "username": {
          "type": "string",
          "description": "The user's username."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "favoriteGenres": {
          "type": "array",
          "description": "An array of the user's favorite anime genres.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "username",
        "email"
      ]
    },
    "Anime": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Anime",
      "type": "object",
      "description": "Represents an anime title available on the platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Anime entity."
        },
        "title": {
          "type": "string",
          "description": "The title of the anime."
        },
        "genre": {
          "type": "string",
          "description": "The genre of the anime."
        },
        "releaseDate": {
          "type": "string",
          "description": "The release date of the anime.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "title",
        "genre",
        "releaseDate"
      ]
    },
    "Watchlist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Watchlist",
      "type": "object",
      "description": "Represents a user's personalized watchlist.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Watchlist entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Watchlist)"
        },
        "animeIds": {
          "type": "array",
          "description": "References to Anime. (Relationship: Watchlist 1:N Anime)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "userId",
        "animeIds"
      ]
    },
    "Comment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Comment",
      "type": "object",
      "description": "Represents a user comment on an anime.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Comment entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Comment)"
        },
        "animeId": {
          "type": "string",
          "description": "Reference to Anime. (Relationship: Anime 1:N Comment)"
        },
        "text": {
          "type": "string",
          "description": "The content of the comment."
        },
        "timestamp": {
          "type": "string",
          "description": "The timestamp of when the comment was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "animeId",
        "text",
        "timestamp"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. Path-based ownership for private user data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/watchlists/{watchlistId}",
        "definition": {
          "entityName": "Watchlist",
          "schema": {
            "$ref": "#/backend/entities/Watchlist"
          },
          "description": "Stores user watchlists. Path-based ownership.  Parent: User",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "watchlistId",
              "description": "The unique identifier for the watchlist."
            }
          ]
        }
      },
      {
        "path": "/anime/{animeId}",
        "definition": {
          "entityName": "Anime",
          "schema": {
            "$ref": "#/backend/entities/Anime"
          },
          "description": "Stores anime information.",
          "params": [
            {
              "name": "animeId",
              "description": "The unique identifier for the anime."
            }
          ]
        }
      },
      {
        "path": "/anime/{animeId}/comments/{commentId}",
        "definition": {
          "entityName": "Comment",
          "schema": {
            "$ref": "#/backend/entities/Comment"
          },
          "description": "Stores comments for each anime. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "animeId",
              "description": "The unique identifier for the anime."
            },
            {
              "name": "commentId",
              "description": "The unique identifier for the comment."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to ensure authorization independence, clarity, and scalability. User data is stored under `/users/{userId}`, providing a clear ownership model. Watchlists are nested under users (`/users/{userId}/watchlists/{watchlistId}`) to maintain the user-watchlist relationship and simplify security rules based on user ownership. Anime data is stored in a flat `/anime/{animeId}` collection. Comments are stored in a subcollection under each anime document (`/anime/{animeId}/comments/{commentId}`), including denormalized `userId` and `timestamp` for each comment. This denormalization allows for efficient querying and avoids the need for complex `get()` calls in security rules. This structure enables efficient list operations (QAPs) as filtering can be performed directly on the denormalized comment documents without needing to access parent anime documents. Overall, this design promotes secure, scalable, and maintainable data access patterns."
  }
}